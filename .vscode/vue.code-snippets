{
  "Vue 3 Composition API Component": {
    "prefix": "vue3-comp",
    "body": [
      "<template>",
      "  <div class=\"${1:component-name}\">",
      "    <!-- TODO: Add template content -->",
      "  </div>",
      "</template>",
      "",
      "<script setup>",
      "import { ref, computed, onMounted } from 'vue'",
      "",
      "// Props with validation",
      "const props = defineProps({",
      "  ${2:propName}: {",
      "    type: ${3:String},",
      "    required: ${4:true},",
      "    validator: (value) => {",
      "      // TODO: Add validation logic",
      "      return true",
      "    }",
      "  }",
      "})",
      "",
      "// Emits with validation",
      "const emit = defineEmits([",
      "  '${5:eventName}'",
      "])",
      "",
      "// Reactive state",
      "const ${6:state} = ref(${7:initialValue})",
      "",
      "// Computed properties",
      "const ${8:computedProp} = computed(() => {",
      "  // TODO: Add computed logic",
      "  return ${6:state}.value",
      "})",
      "",
      "// Methods following single responsibility principle",
      "const ${9:methodName} = () => {",
      "  // TODO: Add method logic",
      "  emit('${5:eventName}', ${6:state}.value)",
      "}",
      "",
      "// Lifecycle hooks",
      "onMounted(() => {",
      "  // TODO: Add mounted logic",
      "})",
      "</script>",
      "",
      "<style scoped>",
      ".${1:component-name} {",
      "  /* TODO: Add component styles */",
      "}",
      "</style>",
    ],
    "description": "Create a Vue 3 component with Composition API following clean code principles",
  },

  "Composable Function": {
    "prefix": "use-composable",
    "body": [
      "import { ref, computed, onMounted, onUnmounted } from 'vue'",
      "",
      "/**",
      " * ${1:Description of what this composable does}",
      " * @param {${2:ParamType}} ${3:paramName} - ${4:Parameter description}",
      " * @returns {Object} The composable's reactive state and methods",
      " */",
      "export function use${5:ComposableName}(${3:paramName}) {",
      "  // Private reactive state",
      "  const ${6:internalState} = ref(${7:initialValue})",
      "  const ${8:loading} = ref(false)",
      "  const ${9:error} = ref(null)",
      "",
      "  // Public computed properties",
      "  const ${10:computedProp} = computed(() => {",
      "    // TODO: Add computed logic",
      "    return ${6:internalState}.value",
      "  })",
      "",
      "  // Private methods (single responsibility)",
      "  const ${11:privateMethod} = async () => {",
      "    try {",
      "      ${8:loading}.value = true",
      "      ${9:error}.value = null",
      "      // TODO: Add private method logic",
      "    } catch (err) {",
      "      ${9:error}.value = err.message",
      "    } finally {",
      "      ${8:loading}.value = false",
      "    }",
      "  }",
      "",
      "  // Public methods",
      "  const ${12:publicMethod} = () => {",
      "    // TODO: Add public method logic",
      "    return ${11:privateMethod}()",
      "  }",
      "",
      "  // Lifecycle management",
      "  onMounted(() => {",
      "    // TODO: Add setup logic",
      "  })",
      "",
      "  onUnmounted(() => {",
      "    // TODO: Add cleanup logic",
      "  })",
      "",
      "  // Public API (Interface Segregation Principle)",
      "  return {",
      "    // State",
      "    ${10:computedProp},",
      "    ${8:loading}: readonly(${8:loading}),",
      "    ${9:error}: readonly(${9:error}),",
      "    ",
      "    // Methods",
      "    ${12:publicMethod}",
      "  }",
      "}",
    ],
    "description": "Create a Vue composable following SOLID principles",
  },

  "Test Suite Template": {
    "prefix": "test-suite",
    "body": [
      "import { describe, it, expect, beforeEach, vi } from 'vitest'",
      "import { ${1:ComponentOrFunction} } from '${2:./path/to/module}'",
      "",
      "describe('${1:ComponentOrFunction}', () => {",
      "  // Test setup",
      "  let ${3:instance}",
      "  let ${4:mockDependency}",
      "",
      "  beforeEach(() => {",
      "    // Arrange - Set up test data and mocks",
      "    ${4:mockDependency} = vi.fn()",
      "    ${3:instance} = new ${1:ComponentOrFunction}(${4:mockDependency})",
      "  })",
      "",
      "  describe('${5:methodOrBehavior}', () => {",
      "    it('should ${6:describe expected behavior}', () => {",
      "      // Arrange",
      "      const ${7:input} = ${8:'test-value'}",
      "      const ${9:expected} = ${10:'expected-result'}",
      "",
      "      // Act",
      "      const ${11:result} = ${3:instance}.${5:methodOrBehavior}(${7:input})",
      "",
      "      // Assert",
      "      expect(${11:result}).toBe(${9:expected})",
      "      expect(${4:mockDependency}).toHaveBeenCalledWith(${7:input})",
      "    })",
      "",
      "    it('should handle edge case: ${12:edge case description}', () => {",
      "      // Arrange",
      "      const ${13:edgeInput} = ${14:null}",
      "",
      "      // Act & Assert",
      "      expect(() => {",
      "        ${3:instance}.${5:methodOrBehavior}(${13:edgeInput})",
      "      }).toThrow('${15:Expected error message}')",
      "    })",
      "",
      "    it('should maintain code coverage above 80%', () => {",
      "      // TODO: Add more test cases to ensure comprehensive coverage",
      "      // Test all branches, error paths, and edge cases",
      "    })",
      "  })",
      "})",
    ],
    "description": "Create a comprehensive test suite with 80%+ coverage goal",
  },

  "Class with SOLID Principles": {
    "prefix": "solid-class",
    "body": [
      "/**",
      " * ${1:Class description following Single Responsibility Principle}",
      " * ",
      " * This class is responsible for: ${2:specific responsibility}",
      " * ",
      " * @example",
      " * const ${3:instance} = new ${4:ClassName}(${5:dependencies})",
      " * const result = ${3:instance}.${6:method}()",
      " */",
      "export class ${4:ClassName} {",
      "  // Private fields (Encapsulation)",
      "  #${7:privateField}",
      "  #${8:dependencies}",
      "",
      "  /**",
      "   * Constructor following Dependency Inversion Principle",
      "   * @param {${9:DependencyInterface}} ${10:dependency} - Injected dependency",
      "   */",
      "  constructor(${10:dependency}) {",
      "    // Validate dependencies (fail fast)",
      "    if (!${10:dependency}) {",
      "      throw new Error('${10:dependency} is required')",
      "    }",
      "",
      "    this.#${8:dependencies} = { ${10:dependency} }",
      "    this.#${7:privateField} = ${11:initialValue}",
      "  }",
      "",
      "  /**",
      "   * Public method following Single Responsibility Principle",
      "   * @param {${12:ParamType}} ${13:param} - Method parameter",
      "   * @returns {${14:ReturnType}} The result",
      "   */",
      "  ${6:method}(${13:param}) {",
      "    this.#${15:validateInput}(${13:param})",
      "    return this.#${16:processData}(${13:param})",
      "  }",
      "",
      "  /**",
      "   * Private validation method (Single Responsibility)",
      "   * @param {${12:ParamType}} ${13:param} - Input to validate",
      "   * @throws {Error} When validation fails",
      "   */",
      "  #${15:validateInput}(${13:param}) {",
      "    if (!${13:param}) {",
      "      throw new Error('${13:param} is required')",
      "    }",
      "    // TODO: Add specific validation logic",
      "  }",
      "",
      "  /**",
      "   * Private processing method (Single Responsibility)",
      "   * @param {${12:ParamType}} ${13:param} - Data to process",
      "   * @returns {${14:ReturnType}} Processed result",
      "   */",
      "  #${16:processData}(${13:param}) {",
      "    // TODO: Add processing logic",
      "    return this.#${8:dependencies}.${10:dependency}.${17:process}(${13:param})",
      "  }",
      "",
      "  /**",
      "   * Getter following Open/Closed Principle",
      "   * @returns {${18:FieldType}} The current value",
      "   */",
      "  get ${19:propertyName}() {",
      "    return this.#${7:privateField}",
      "  }",
      "}",
    ],
    "description": "Create a class following SOLID principles with proper encapsulation",
  },

  "Conventional Commit": {
    "prefix": "commit-msg",
    "body": [
      "${1|feat,fix,docs,style,refactor,test,chore,perf,ci,build,revert|}${2:(${3:scope})}: ${4:description}",
      "",
      "${5:Optional body explaining the change in more detail}",
      "",
      "${6:Optional footer with breaking changes or issue references}",
      "${7:BREAKING CHANGE: ${8:description of breaking change}}",
      "${9:Fixes #${10:issue-number}}",
    ],
    "description": "Template for Conventional Commits 1.0.0 format",
  },
}
